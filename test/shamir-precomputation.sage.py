

# This file was *autogenerated* from the file test/shamir-precomputation.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF = Integer(0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF); _sage_const_0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC = Integer(0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC); _sage_const_0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B = Integer(0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B); _sage_const_0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296 = Integer(0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296); _sage_const_0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5 = Integer(0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5); _sage_const_0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551 = Integer(0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16); _sage_const_256 = Integer(256); _sage_const_4 = Integer(4); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_64 = Integer(64); _sage_const_7 = Integer(7); _sage_const_255 = Integer(255)#//**********************************************************************************************/
#//  ___           _       ___               _         _    _ _
#// | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__
#// | _| '_/ -_|_-< ' \  | (__| '_| || | '_ \  _/ _ \ | |__| | '_ \
#// |_||_| \___/__/_||_|  \___|_|  \_, | .__/\__\___/ |____|_|_.__/
#//                                |__/|_|
#// Copyright (C) 2022 - Renaud Dubois - This file is part of FCL (Fresh CryptoLib) project     */
#// License: This software is licensed under MIT License 	                                    */
#// See LICENSE file at the root folder of the project.				                            */
#// FILE: FCL_ecdsa_precompute.sage						                                        */
#// 											                                                */
#// 											                                                */
#// DESCRIPTION: precompute a 8 dimensional table for Shamir's trick from a public key
#//
#//**********************************************************************************************/

import os
import sys

# load he library needed to perform the precomputation
def Init_Curve(curve_characteristic,curve_a, curve_b,Gx, Gy, curve_Order):
	Fp=GF(curve_characteristic); 				#Initialize Prime field of Point
	Fq=GF(curve_Order);					#Initialize Prime field of scalars
	Curve=EllipticCurve(Fp, [curve_a, curve_b]);		#Initialize Elliptic curve
	curve_Generator=Curve([Gx, Gy]);

	return [Curve,curve_Generator];

#//curve secp256r1, aka p256
#//curve prime field modulus
sec256p_p = _sage_const_0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF ;
#//short weierstrass first coefficient
sec256p_a =_sage_const_0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC ;
#//short weierstrass second coefficient
sec256p_b =_sage_const_0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B ;
#//generating point affine coordinates
sec256p_gx =_sage_const_0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296 ;
sec256p_gy =_sage_const_0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5 ;
#//curve order (number of points)
sec256p_n =_sage_const_0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551 ;

#//Init the curve
secp256r1, G = Init_Curve(sec256p_p, sec256p_a, sec256p_b, sec256p_gx, sec256p_gy, sec256p_n);

def precompute_pubkey(Q, Curve):
  # Initialize the precomputed table and the powers of 64*q
  Pow64_PQ=[ Q for i in range(_sage_const_0 ,_sage_const_16 )];
  Prec=[ Curve(_sage_const_0 ) for i in range(_sage_const_0 ,_sage_const_256 )];
  Pow64_PQ[_sage_const_0 ]=Curve([sec256p_gx, sec256p_gy]);
  Pow64_PQ[_sage_const_4 ]=Q;

   # Compute the powers of 64*q
  for j in (ellipsis_range(_sage_const_1 ,Ellipsis,_sage_const_3 )):
    Pow64_PQ[j]=_sage_const_2 **_sage_const_64 *Pow64_PQ[j-_sage_const_1 ];
    Pow64_PQ[j+_sage_const_4 ]=_sage_const_2 **_sage_const_64 *Pow64_PQ[j+_sage_const_3 ];

  # Compute the precomputed table
  Prec[_sage_const_0 ]=Curve(_sage_const_0 );
  for i in range(_sage_const_1 ,_sage_const_256 ):
    Prec[i]=Curve(_sage_const_0 );
    for j in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_7 )):
      if( (i&(_sage_const_1 <<j))!=_sage_const_0 ):
        (Prec[i])=(Pow64_PQ[j]+ Prec[i]);

  # Return the precomputed table
  return Prec;

def print_setlength(X, n):
    # Convert X to a hexadecimal string and remove the '0x' prefix
    hex_str = hex(X)[_sage_const_2 :]

    # Add leading zeros to the string to make it length n
    return hex_str.rjust(n, '0')

def get_concatenate_point(Prec):
  coords = ""

  # Concatenate the x and y coordinates of each point in Prec
  for i in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_255 )):
    px=print_setlength( Prec[i][_sage_const_0 ], _sage_const_64 );
    py=print_setlength( Prec[i][_sage_const_1 ], _sage_const_64 );
    coords=coords+px+py;

  # Join the coordinates into a single string
  return coords

if __name__ == '__main__':
  # Load the C0 and C1 environment variables
  C0 = int(os.environ['C0'])
  C1 = int(os.environ['C1'])

  # Compute the precomputed table
  q = secp256r1([C0, C1])
  Prec = precompute_pubkey(q, secp256r1)

  # Get the concatenated points and write them to stdout
  concatenated_points = get_concatenate_point(Prec)
  sys.stdout.write(concatenated_points)

